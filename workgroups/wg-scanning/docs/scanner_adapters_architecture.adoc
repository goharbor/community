= Harbor :: Scanner Adapters Architecture
:icons: font
:source-highlighter: coderay
:toc:

== Overview

Currently Harbor is closely coupled with https://github.com/coreos/clair[Clair] to scan images stored in its Docker
_Registry_. The idea is integrate Harbor with any compatible image scanner by simple means of configuration
changes. By doing so Clair could be replaced with an open source or commercial alternatives.

The main objective of this proposal is to deliver the design of a minimum valuable product (MVP) of pluggable image
scanners. At the same time the MVP should be extensible to cater for further improvements.

== Harbor and Clair

Currently the code for submitting scan requests and fetching scan results from Clair is part of the Harbor's codebase.

.The deployment diagram for the current Harbor integration with Clair.
plantuml::diagrams/deployment-harbor-clair.plantuml[deployment-harbor-clair, png]

The current workflow for scanning images is depicted below with the detailed explanation beneath.

.The sequence diagram for the current Harbor integration with Clair.
plantuml::diagrams/sequence-harbor-clair.plantuml[sequence-harbor-clair, png]

1. A _User_ requests a scan of selected image by clicking the Scan button.
2. The system schedules a _ClairJob_ for execution.
3. The _ClairJob_ pulls image manifest from _Registry_.
4. The _ClairJob_ parses the image manifest. For each image layer it creates an instance of `ClairLayer` structure,
   which is an internal representation of the layer in Clair. Each `ClairLayer` has `Name`, `Path`, and
   `Authorization` header properties that allow Clair to pull the image.
5. The _ClairJob_ pushes a slice of `ClairLayer` items to _Clair API_ for the actual scanning.
6. The _ClairJob_ pulls the scan result from _Clair API_.
7. The _ClairJob_ transforms scan result to the components overview model represented by the `ComponentsOverview`
   structure. The `ComponentsOverview` model is understandable by the Harbor's UI and policy checker.
8. The _ClairJob_ saves the components overview to the _Harbor DB_. (It's used later on to enforce simple policy rules,
   e.g. preventing users from pulling an image which contains severe vulnerabilities.) The parent ``ClairLayer``s Name is
   also stored in _Harbor DB_ and used later on to fetch scan results.
9. The _User_ clicks the Refresh button or the UI timer triggers the scan results refresh.
10. The _Repository API Handler_ calls the `VulnerabilitiesDetails` method of _Repository API_.
11. The _Repository API_ downloads scan result for the persisted ``ClairLayer``'s Name.
12. The `ScanResult` is transformed to the Harbor's model, i.e. a slice of ``VulnerabilityItem``s so it can be rendered
    in the UI as a grid of vulnerabilities.

== Scanner Adapter

"...We can solve any problem by introducing an extra level of indirection."

Having said that imagine that instead of calling directly _Clair API_, the _ClairJob_ sends request to _Clair Scanner
Adapter API_ which in turn calls the _Clair API_. The _Clair Scanner Adapter API_ is given all params to pull the image
from the Harbor's registry.

.The deployment diagram for the proposed Harbor integration with Scanner Adapter API.
plantuml::diagrams/deployment-harbor-scanner-adapter.plantuml[deployment-harbor-scanner-adapter, png]

This indirection introduced by the _Scanner Adapter API_ abstraction allows one to implement a generic `ScannerJob` and
`scanner.Client` once and reuse them with every imaginable scanner. In this approach the responsibility of integrating
the scanner with Harbor is delegated to the corresponding _Scanner Adapter API_ implementation. For example, we can
have a dedicated `harbor-clair-adapter`, or `harbor-microscanner-adapter`. The only requirement is that each adapter
implements a well defined API and is deployed as a separate microservice.

.The sequence diagram for the proposed Harbor integration with Scanner Adapter API.
plantuml::diagrams/sequence-harbor-scanner-adapter.plantuml[sequence-harbor-scanner-adapter, png]

1. A _User_ requests a scan of selected image by clicking the Scan button.
2. The system schedules a _ScannerJob_ for execution. The _ScannerJob_ instantiates the generic `scanner.Client`.
   The only configuration passed to the client is the endpoint URL of the configured _Scanner Adapter API_.
3. The _ScannerJob_ prepares a scan request.
4. The _ScannerJob_ submits the scan request to _Scanner Adapter API_.
5. The _ScannerJob_ pulls the scan result from _Scanner Adapter API_.
6. The _ScannerJob_ transform scan result to the components overview model.
7. The _ScannerJob_ saves the components overview to the _Harbor DB_.
8. The _User_ clicks the Refresh button or the UI timer triggers the scan results refresh.
9. The _Repository API Handler_ calls the `VulnerabilitiesDetails` method of _Repository API_.
10. The _Repository API_ pulls scan result for the image digest.
11. The scan result is transformed to the Harbor's model, i.e. the slice of ``VulnerabilityItem``s.

=== Scanner Adapter API

The API is inspired by Clair. It provides the bunch of operations described in the subsequent sections.

==== API Version Check

A minimal endpoint, mounted at `/v1` will provide version support information based on its response statuses. The
request format is as follows:

----
GET /v1
----

If `200 OK` response is returned, the Scanner Adapter implements the V1 API and the client may proceed safely with
other operations.

==== Submit Scan Request

Image scanning is triggered by POST request in the following format:

----
POST /v1/scan
Content-Type: application/json

{
  "registry_url":   "https://harbor-harbor-registry:5000/",
  "registry_token": "JWTTOKENGOESHERE",
  "repository":     "library/oracle/nosql",
  "tag":            "latest"

  "digest: "sha256:9cb763a2a55567ebf4c1d6a70d83d5d032892c8d5aee8ea5894ef0a3c3786e54",
}
----

If `201 Created` response is returned, the scan request was submitted successfully and the client may proceed with
getting the corresponding scan result.

----
201 Created

{
  "details_key": "sha256:9cb763a2a55567ebf4c1d6a70d83d5d032892c8d5aee8ea5894ef0a3c3786e54" <1>
}
----
<1> The details key is used to fetch scan result. It can be digest or any other identifier. For example,
Clair is using layer name as a key to fetch scan result.

The JSON request payload contains all data that allows Scanner Adapter to pull image from the Harbor's Registry.
For example, it should be able to send the following requests:

----
GET https://harbor-harbor-registry:5000/v2/library/oracle/nosql/manifests/sha256:b1165286043f2745f45ea637873d61939bff6d9a59f76539d6228abf79f87774
Authorization: Bearer JWTTOKENGOESHERE
----

----
GET https://harbor-harbor-registry:5000/v2/library/oracle/nosql/blobs/sha256:b113c8b260349e1adcfea8f2909d26e4a0a5c3bb6ef6e93e47fc22cf8d3fc7d5
Authorization: Bearer JWTTOKENGOESHERE
----

==== Get Scan Result

To get the scan result for the given image digest the following request has to be sent:

----
GET /v1/scan/<detailsKey>
----

The response will be in the following format:

----
200 OK
Content-Type: application/json

{
  "severity": 5,
  "overview": {
    "total": 2,
    "summary": [
      {"severity": 1, "count": 0},
      {"severity": 2, "count": 0},
      {"severity": 3, "count": 1},
      {"severity": 4, "count": 0},
      {"severity": 5, "count": 1}
    ]
  },
  "vulnerabilities": [
    {
      "id": "CVE-2017-18018",
      "severity": 5,
      "package": "coreutils",
      "version": "8.23-4",
      "description": "In GNU Coreutils through 8.29, chown-core.c in ..." chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX \"-R -L\" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.",
      "link": "https://security-tracker.debian.org/tracker/CVE-2017-18018"
    },
    {
      "id": "CVE-2017-8283",
      "severity": 3,
      "package": "dpkg",
      "version": "1.17.27",
      "description": "dpkg-source in dpkg 1.3.0 through 1.18.23 is able to use a non-GNU patch program and does not offer a protection mechanism for blank-indented diff hunks, which allows remote attackers to conduct directory traversal attacks via a crafted Debian source package, as demonstrated by use of dpkg-source on NetBSD.",
      "link": "https://security-tracker.debian.org/tracker/CVE-2017-8283"
    }
  ]
}
----

NOTE: The returned JSON which represents scan results reuses the current Harbor's model for components overview
(`ComponentsOverview`) and vulnerability representation (`VulnerabilityItem`). This is done deliberately in V1 of the API
to minimize the impact of changes in the code (JavaScript / DB migrations) but still deliver a MVP.

=== Harbor Configuration

The Harbor's config would have a very generic structure as the only required configuration parameter is the URL of the
_Scanner Adapter API_. In other words, Harbor is not aware of any vendor specific configuration options such as access
tokens, upstream vulnerability databases and so on. Vendor specific scanner configuration should be handled by
the _Scanner Adapter API_ and the scanner itself.

.A snippet of Harbor config pertinent to the image scanning.
[source,yaml]
----
# You can switch an image scanner by changing its endpoint URL.
imageScanner:
  # Use CoreOS Clair for image scanning
  name: "Clair"
  vendor: "CoreOS"
  endpointURL: "http://harbor-clair-adapter:6000/"

  # Alternatively use Aqua Security Microscanner
  # name: "Microscanner"
  # vendor: "Aqua Security"
  # endpointURL: "http://harbor-microscanner-adapter:8080/"

# See https://martinfowler.com/articles/feature-toggles.html
featureToggles:
  # If it's turned on a new scanner adapter is enabled, if it's off we
  # fall back to the existing scanning with Clair.
  SCANNER_ADAPTER: "on" <1>
----
<1> A very simplistic approach to implement a feature flag mechanism.

=== Implementation and Deployment

The implementation of such architecture can be executed as follows:

1. Introduce a https://martinfowler.com/articles/feature-toggles.html[feature toggle], e.g. `SCANNER_ADAPTER=[on|off]`,
   to enabled/disable scanner adapters functionality. This will allow us to experiment and deliver the code incrementally.
2. Implement a generic `scanner.Client` to communicate with the _Scanner Adapter API_:
+
[source,go]
----
package scanner

// ScanRequest represents a structure that is sent to Scanner Adapter API
// with all the details required to fetch image meta-data and layers.
type ScanRequest struct {
	RegistryURL   string `json:"registry_url"`
	RegistryToken string `json:"registry_token"`
	Repository    string `json:"repository"`
	Tag           string `json:"tag"`
	Digest        string `json:"digest"`
}

type ScanResponse struct {
	DetailsKey string `json:"details_key"`
}

// ScanResponse represents the outcome of the image scan.
type ScanResult struct {
	Severity Severity `json:"severity"`
	Overview *ComponentsOverview `json:"overview"`
	Vulnerabilities []*VulnerabilityItem `json:"vulnerabilities"`
}

// Severity represents the severity of a image/component in terms of vulnerability.
type Severity int64

type ComponentsOverview struct {
	Total   int `json:"total"`
	Summary []ComponentsOverviewEntry `json:"summary"`
}

type ComponentsOverviewEntry struct {
	Sev int `json:"severity"`
	Count int `json:"count"`
}

type VulnerabilityItem struct {
	ID          string   `json:"id"`
	Severity    string   `json:"severity"`
	Pkg         string   `json:"package"`
	Version     string   `json:"version"`
	Description string   `json:"description"`
	Link        string   `json:"link"`
	Fixed       string   `json:"fixedVersion,omitempty"`
}

type ImageScanner interface {
	Scan(req ScanRequest) (*ScanResponse, error)
	GetResult(detailsKey string) (*ScanResult, error)
}
----
3. Implement `ScannerJob` by porting the logic from `ClairJob` and using a fresh `scanner.Client` instead of existing
   `clair.Client`.
4. Modify the code that actually schedules `ClairJob`. The code should read the `SCANNER_ADAPTER` feature flag.
   If it's `off` it should fallback to submitting a `ClairJob`. If it's `on` it should run the `ScannerJob`.
5. Similarly modify the _Repository API_ HTTP handler for fetching scan details, i.e. if the `SCANNER_ADAPTER` feature flag is `on`, use
   `scanner.Client` instead of `clair.Client`.
6. Implement `clair-harbor-adapter` as a reference implementation. Host it in a dedicated repository,
   e.g. https://github.com/goharbor/harbor-clair-adapter.

=== Summary

==== Advantages

1. Quite simple to implement incrementally and deploy behind a feature toggle.
2. Preserve existing data model. No changes to the database models.
3. Scalable in terms of Harbor's code base and community contributions. Not a monolith.
   (Harbor does have to know about Scanner X or Scanner Y. Instead Scanner X and Scanner Y knows about Harbor.)
4. DRY Write `scanner.Client` once and reuse it everywhere.

==== Disadvantages

1. Additional abstraction layer and additional hop in troubleshooting problems or debugging code.
2. Maintain the scanner adapter's API.
3. Evaluate upfront whether the API is flexible enough to cater for all use cases.

== POC

https://github.com/danielpacak/harbor/tree/scanner_adapters_poc

=== Microscanner Adapter

https://github.com/danielpacak/harbor-microscanner-adapter

.The deployment diagram for the proposed Harbor integration with Microscanner.
plantuml::diagrams/deployment-harbor-microscanner.plantuml[deployment-harbor-microscanner, png]

=== Clair Adapter

https://github.com/danielpacak/harbor-clair-adapter

# Proposal: Pluggable Image Vulnerability Scanning

Authors: Daniel Pacak @danielpacak, Zach Hill @zhill

Discussions:
1. [The first issue opened by @lizrice](https://github.com/goharbor/harbor/issues/6234)
2. [Initial working draft of pluggable scanning proposal and working group by @zhill](https://github.com/goharbor/community/pull/82)
3. [Scanner Adapters architecture proposal by @danielpacak](https://github.com/goharbor/community/pull/90)
4. [Pluggable Scanners PRD by Alex Xu](https://docs.google.com/document/d/1CGqhf1KNzajmg69h8K6OoFhx7mLXSbGjukZGCXM82vs/edit)

## TOC

- [Abstract](#abstract)
- [Background](#background)
  - [Image Scanning with Clair](#image-scanning-with-clair)
- [Proposal](#proposal)
  - [Image Scanning with Scanner Adapter](#image-scanning-with-scanner-adapter)
  - [Scanner Adapter API](#scanner-adapter-api)
  - [Artifact Data Access](#artifact-data-access)
  - [Scanner Adapter API](#scanner-adapter-api)
  - [Scanner Registry](#scanner-registry)
  - [Configuration](#configuration)
  - [Scanner Adapter Client](#scanner-adapter-client)
  - [Scan Controller](#scan-controller)
  - [ScanReports Storage](#scanreports-storage)
- [Non-Goals](#non-goals)
- [Rationale](#rationale)
- [Compatibility](#compatibility)
- [Implementation](#implementation)
  - [Work Items](#work-items)
- [Open issues](#open-issues-if-applicable)

## Abstract

Add support to Harbor for using other image scanners than just [Clair][clair] by replacing the current Clair-specific
scanning job implementation with an adapter layer implemented as an HTTP API between Harbor and the scanners' native
interfaces. This will provide runtime configurable scanner invocation to provide vulnerability scanning initially with
the option for other types of scanning in the future.

Introduce:
1. Scanner Adapter HTTP API (defined and maintained by Harbor)
   - Core operations:
     - Execute a scan (non-blocking)
     - Retrieve a scan report (polling by Harbor)
     - Describe the scanner’s capabilities, i.e. supported artifacts and reports
2. Scanner Adapter HTTP client in Harbor
3. Scanner Adapter configuration management and persistence in the Harbor DB

The adapter interface is a well-defined REST API specified and maintained by Harbor. Harbor will have a client for the
API, and manage configuration of the client. The configuration is primarily an endpoint registration, and multiple
configurations will be supported concurrently in the system. This will allow user-selectable and configurable scanning
of images at runtime with no restarts for Harbor required. Scanner adapters must implement the specified API, but the
deployment and configuration of the adapter services themselves is out-of-scope for this proposal and Harbor itself is
not responsible for management or deployment of the adapter services.

## Background

Based on discussions with the Harbor users and maintainers, there is a long-term desire to introduce flexible and
configurable artifact scanning integration capabilities into Harbor with the aim of allowing Harbor admins and users to
configure, at runtime, and on a per-project basis:

1. The set of scans that should be executed on artifacts in the project
   - Examples: vulnerability scan, software license scan, malware scan
   - Artifacts to be scanned examples: images, helm charts, CPAN bundles
2. The way that the results of the scans should be interpreted and combined to produce a final binary acceptance result
   for the artifact that can subsequently be used to optionally control user access to the artifact
3. Persistence of the scan results in support of audit history
4. Visualizations of some or all of the scan results for users directly in Harbor

Given that broader long-term objective, this proposal addresses the initial steps required to provide pluggable image
scanning for vulnerabilities, while providing the framework to build upon towards the longer-term artifact scanning
objective. Thus, this proposal can be considered phase 1 of a multi-phase work to achieve the above objectives.

### Image Scanning with Clair

<details><summary>CLICK TO SHOW</summary>
<p>

The components responsible for submitting scan requests and fetching scan results from Clair are part of the Harbor’s
deployment.

![harbor-clair-deployment][harbor-clair-deployment-img]

The diagram below shows the current workflow for scanning images with the detailed explanation beneath.

![harbor-clair-sequence][harbor-clair-sequence-img]

1. A User requests a scan of selected image by clicking the Scan button.
2. The system schedules a ClairJob for execution.
3. The ClairJob pulls the manifest of the image from Registry.
4. The ClairJob parses the manifest. For each image layer it creates an instance of `ClairLayer` structure, which
   is an internal representation of an image layer in Clair. Each `ClairLayer` has Name, Path, and Authorization
   header properties that allow Clair to pull the image thru Docker Registry v2 API exposed by Harbor.
5. The ClairJob pushes a slice of `ClairLayer` items to Clair API for the actual scanning. Note that this is
   a **blocking** operation.
6. The ClairJob pulls the scan result from Clair API.
7. The ClairJob transforms scan result to the components overview model represented by the `ComponentsOverview`
   structure. The `ComponentsOverview` model is understandable by the Harbor web console and simple policy checker.
8. The ClairJob saves the components overview to the Harbor DB. (It’s used later on to enforce simple policy rules,
   e.g. preventing users from pulling an image which contains severe vulnerabilities.) The name of the parent
   `ClairLayers`, aka `DetailsKey`, is stored in Harbor DB and used later on to fetch scan results.
9. The User clicks the Refresh button or the UI timer triggers the scan results refresh.
10. The Repository API Handler calls the `VulnerabilitiesDetails` method of Repository API.
11. The Repository API downloads Clair scan result for the corresponding `DetailsKey`.
12. The `ClairScanResult` is transformed to the Harbor’s model, effectively a slice of `VulnerabilityItem`s so it can be
    rendered in the UI as a grid of security vulnerabilities.

</p>
</details>

## Proposal

To achieve the goal of runtime configurable and pluggable container image vulnerability scanning, the current
Clair-specific logic will be abstracted out and replaced with a generic scanner configuration, selection, and invocation
framework based on a simple HTTP API that Harbor will call on adapters that wrap the scanner implementations.

The proposed work focuses on building the adapter framework and leaves scan result interpretation, combination, and
selection issues to future work by leveraging the existing lifecycle and invocation triggers for the scans themselves
and only replacing the mechanisms for executing scans and persisting results. Current scan invocation triggers will
remain:

1. Users can set a scan schedule on some set of images in a project
2. Users can explicitly request a scan

New Components:
1. **Scanner Adapter API** - HTTP API defining the interface between Harbor and artifact scanners.
   1. Defined and maintained by Harbor
   2. Versioned
   3. REST-based
   4. Specified by OpenAPI/Swagger spec
   5. Authentication specifics are out-of-scope, but should be supported using the HTTP `Authorization` header
2. **Scanner Adapter** - HTTP Service that implements the Scanner Adapter API and manages translation of the Scanner
   Adapter API to/from native APIs/CLIs that scanners implement
   1. Deployed outside the system boundary of Harbor, not considered an internal component
   2. Implementations are out-of-tree of Harbor
   3. Has independent state management, configuration, and deployment lifecycle from Harbor
3. **Scanner Registry** - An internal component logically responsible for managing the configurations for invoking a
   scanner adapter
   1. Backed by persistence in the DB
   2. Basic CRUD semantics via new Harbor APIs
4. **Scanner Registration** - A named configuration for invoking a scanner via its adapter
   1. Name - The name of the entry, must be globally unique in Harbor
   2. Description - A description of the scanner for human consumption
   3. Endpoint - The hostname and port to invoke the Adapter API calls against
   4. Authorization Configuration - The optional value to set in the HTTP `Authorization` header
   5. NOTE: no plan for preventing duplicate entries based on endpoint etc as such constraints can be delegated to the
      system administrator’s discretion based on deployment specific requirements.
5. **Scanner Adapter Client** - An HTTP client that takes a registration as configuration input and invokes Scanner
   Adapter API calls to initiate scans, retrieve results, query health, and refresh metadata from Scanner Adapter(s).
7. **Scan Job** - The unit-of-work for executing and retrieving results for a scan of an artifact in the Harbor
   registry.
   1. This may be extended to include an aggregation meta-job that defines and executes multiple Scan Jobs themselves
      and combines their results in a specific way
   2. Identified by a UUID, each job is unique
8. **Scan Report** - the output of a Scan Job, the type and content of which depend on the adapter that was called by the
   Scan Job (e.g. image vulnerability scan vs license compliance scan will have different results with different
   schemas and MIME types)

Updated Components:
1. **Scan Controller** - The main coordinator of the whole scanning procedure.

The main focus of this proposal and the subsequent sections is the Scanner Adapter API design as it must be stable for
Scanner Adapter implementers. Harbor-internal design is secondary as this can evolve independently of the Scanner
Adapter API as long as the contract between the two is set.

### Image Scanning with Scanner Adapter

The indirection introduced by the Scanner Adapter framework allows implementation of a generic Scan Job which in turn
uses a generic Scanner Adapter Client. Both are agnostic to the underlying scanner internals or upgrades.

Such architecture is also extensible to triggering multiple Scanner Adapters for a single scan request. This would require
aggregating ScanReports coming from each Scanner Adapter but is certainly doable without changing the contract
between Harbor service and Scanner Adapters. For example, there might be a `ScanReportAggregate` struct which holds
a collection of `ScanReport`s. Such an aggregate can be visualised in Harbor Web console as a tabbed pane, with each tab
corresponding to a scanner involved.

![harbor-scanner-adapter-deployment][harbor-scanner-adapter-deployment-img]

![harbor-scanner-adapter-sequence][harbor-scanner-adapter-sequence-img]

1. A User requests a scan of selected Artifact by clicking the Scan button.
2. The Harbor API forwards the request to the Scan Controller.
3. The Scan Controller retrieves the default Scanner Registration from the Scanner Registry.
4. The Scan Controller enqueues a Scan Job with params.
5. The Scan Job instantiates the generic Scanner Adapter Client passing Registry Settings as constructor args.
6. The Scan Job creates a ScanRequest. (Scan Job is responsible for generating a UUID for the ScanRequest. It's used
   later on to retrieve the corresponding ScanReport.)
7. The Scan Job sends the ScanRequest to a Scanner Adapter, which in turn, forwards the request to the underlying Scanner.
8. At this stage the Scanner pulls the Artifact to perform the actual scan for vulnerabilities and generate the report.
9. The Scan Job blocks and periodically pulls the ScanReport from the Scanner Adapter until the report is available.
   Note the identifier of the ScanRequest and the MIME type passed to retrieve a ScanReport.
10. The Scan Job emits a `ScanCompleted` event.
11. The `ScanCompleted` event is dispatched to the Event Handler.
12. The Event Handler saves the ScanReport along with its MIME type and the Artifact's digest to the Harbor DB.
13. The User requests refresh of the vulnerabilities report for an Artifact.
14. The Harbor API retrieves the ScanReport for the given Artifact from the Harbor DB thru Scan Store.

### Artifact Data Access

Scanners need access to the artifact data, images in this case. Scanners will retrieve data from Harbor for analysis
using existing Harbor APIs and optionally credentials. The specific APIs used will vary by the artifact being analyzed,
but for the initial image analysis, the image data is retrieved by the scanner using the Docker Registry v2 API exposed
by Harbor. Necessary credentials are presented to the scanner by the scanner adapter as provided in the API call by
Harbor during initiation of a scan.

### Scanner Adapter API

Scanner vendors are supposed to implement Scanner Adapters exposing the Scanner Adapter API as specified in
[Scanner Adapter OpenAPI Specification v1.0.0](assets/pluggable-image-vulnerability-scanning/scanner-adapter-openapi-v1.0.0.yaml).

> Note: OpenAPI spec yaml file can be opened in the online [Swagger Editor](https://editor.swagger.io).

- The deployment method is up to the vendor as long as the mounted API endpoint URL is accessible to Harbor services.
- Scan Job UUID should be a scan request ID used in conjunction with the artifact ID, i.e. artifact repository and
  digest, and not treated as persisted in the Scanner Adapter.
- The lifetime of Scan Job UUIDs in a Scanner Adapter is defined by the adapter. A Scan Job may get a 404 response
  status for a UUID and should treat it as failed and return a failure in the job. Harbor is expected to execute a new
  Scan Job in that case.
- Scanner Adapters are not expected to persist scan reports or make responses for ScanJob UUID + artifact ID immutable.
- Scan Job UUIDs are correlation IDs, not result set identifiers.
- Scanner Adapter API leverages content negotiation by using MIME types in `Accept` header to define schema of a result
  returned by GET `/scan/{scan_request_id}/report` requests.

#### Sample Interaction between Harbor and Scanner Adapter

1. Make sure that the Scanner Adapter has expected capabilities:
   ```
   curl -H 'Accept: application/vnd.scanner.adapter.metadata+json; version=1.0" \
     http://scanner-adapter:8080/api/v1/metadata

   Content-Type: application/vnd.scanner.adapter.scanner.metadata+json; version=1.0
   Status: 200 OK

   {
     "scanner": {
       "name": "Microscanner",
       "vendor": "Aqua Security",
       "version": "3.0.5",
     },
     "capabilities": [
       {
         "artifact_mime_types": [
           "application/vnd.oci.image.manifest.v1+json",
           "application/vnd.docker.distribution.manifest.v2+json"
         ],
         "report_mime_types": [
           "application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0",
           "application/vnd.scanner.adapter.vuln.report.raw"
         ]
       }
     ]
   }
   ```
2. Generate a scan request UUID:
   ```
   SCAN_REQUEST_ID=$(uuidgen | tr "[:upper:]" "[:lower:]")
   ```
3. Submit the scan request:
   ```
   curl http://scanner-adapter:8080/api/v1/scan \
   -H 'Content-Type: application/vnd.scanner.adapter.scan.request+json; version=1.0' \
   -d @- << EOF
   {
     "id": "${SCAN_REQUEST_ID}",
     "registry": {
       "url": "harbor-harbor-registry:5000",
       "authorization": "Bearer: JWTTOKENGOESHERE"
     },
     "artifact": {
       "repository": "library/mongo",
       "digest": "sha256:917f5b7f4bef1b35ee90f03033f33a81002511c1e0767fd44276d4bd9cd2fa8e"
     }
   }
   EOF

   Status: 202 Accepted
   ```
4. Try getting scan report (in unified Harbor format understandable by Harbor Web console):
   ```
   curl -H 'Accept: application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' \
     http://scanner-adapter:8080/api/v1/scan/${SCAN_REQUEST_ID}/report

   Retry-After: 15
   Status: 302 Found
   ```
5. Wait 15 seconds or use your own retry interval ...
6. ... and try getting scan report again:
   ```
   curl -H 'Accept: application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' \
     http://scanner-adapter:8080/api/v1/scan/${SCAN_REQUEST_ID}/report

   Content-Type: application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0
   Status: 200 OK
   
   {
     "generated_at": "2019-08-07T12:17:21.854Z",
     "artifact": {
       "repository": "library/mongo",
       "digest": "sha256:917f5b7f4bef1b35ee90f03033f33a81002511c1e0767fd44276d4bd9cd2fa8e"
     },
     "scanner": {
       "name": "Microscanner",
       "vendor": "Aqua Security",
       "version": "3.0.5",
     },
     "severity": "High",
     "components" : {
       "total": 120",
       "summary": [
         {
           "severity": "High",
           "count": 3
         },
         {
           "severity": "Low",
           "count": 5
         }
       ]
     },
     "vulnerabilities": [
       {
         "id": "CVE-2017-8283",
         "package": "dpkg",
         "version": "1.17.27",
         "fix_version": "1.18.0",
         "severity": "High",
         "description": "...",
         "links": [
           "https://security-tracker.debian.org/tracker/CVE-2017-8283"
         ]
       },
       ...
     ]
   }
   ```
7. Alternatively we could request a proprietary vulnerability report (with an example report generated
   by MicroScanner in JSON format):
   ```
   curl -H 'Accept: application/vnd.scanner.adapter.vuln.report.raw' \
      http://scanner-adapter:8080/api/v1/scan/${SCAN_REQUEST_ID}/report

   Content-Type: application/vnd.scanner.adapter.vuln.report.raw
   Status: 200 OK

   {
     "scan_started": {
       "seconds": 1561386673,
       "nanos": 390482870
     },
     "scan_duration": 2,
     "digest": "b3c8bc6c39af8e8f18f5caf53eec3c6c4af60a1332d1736a0cd03e710388e9c8",
     "os": "debian",
     "version": "8",
     "resources": [
       {
         "resource": {
           "format": "deb",
           "name": "apt",
           "version": "1.0.9.8.5",
           "arch": "amd64",
           "cpe": "pkg:/debian:8:apt:1.0.9.8.5",
           "name_hash": "583f72a833c7dfd63c03edba3776247a"
         },
         "scanned": true,
         "vulnerabilities": [
           {
             "name": "CVE-2011-3374",
             "vendor_score_version": "Aqua",
             "vendor_severity": "negligible",
             "vendor_statement": "Not exploitable in Debian, since no keyring URI is defined",
             "vendor_url": "https://security-tracker.debian.org/tracker/CVE-2011-3374",
             "classification": "..."
           }
         ]
       }
     ]
   }
   ```

- The `Accept` request header is required to indicate to Scanner Adapter an intended scan report format
- If the client does not specify the `Accept` header it's assumed to be Harbor vulnerability report with the
  MIME type `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0`.
- In phase 1 each Scanner Adapter should support at least the following artifact MIME types:
  - `application/vnd.oci.image.manifest.v1+json`
  - `application/vnd.docker.distribution.manifest.v2+json`
- In phase 1 each Scanner Adapter should support at least the following scan report MIME types:
  - `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0` - corresponds to `HarborVulnerabilityReport`
     - fixed schema described in Scanner Adapter API spec
     - can be parsed in type-safe manner and displayed in Harbor Web console.
  - `application/vnd.scanner.adapter.vuln.report.raw`
    - corresponds to a raw scan report
    - no fixed schema, documented by a scanner's vendor
- New scan report MIME types might be introduced without breaking the backward compatibility of the API and introducing
  new URL paths to the Scanner Adapter API spec.
- For example, there can be a vendor specific policy report returned by Anchore with the corresponding MIME type
  `application/vnd.anchore.policy.report+json; version=0.3`:
  ```json
  [
    {
      "sha256:57334c50959f26ce1ee025d08f136c2292c128f84e7b229d1b0da5dac89e9866": {
        "docker.io/alpine:latest": [
          {
            "detail": {},
            "last_evaluation": "2019-08-07T06:33:48Z",
            "policyId": "2c53a13c-1765-11e8-82ef-23527761d060",
            "status": "pass"
          }
        ]
      }
    }
  ]
  ```

### Scanner Registry

Provides a management interface to Harbor API and Scan Controller to register Scanner Adapters and retrieve the
configuration of the default Scanner Adapter to perform the actual scans.

```go
package scanner

// RegistrationSettings consists of EndpointURL and optional Authorization properties to test connection
// with the corresponding Scanner Adapter.
type RegistrationSettings struct {
    // A base URL of the Scanner Adapter.
    EndpointURL    string
    // An optional value of the HTTP Authorization header sent with each request to the Scanner Adapter API.
    Authorization  string
    // SkipCertVerify a flag indicating whether the client should verify the Scanner Adapter's certificate.
    SkipCertVerify bool
}

// Registration represents a named configuration for invoking a scanner via its adapter.
type Registration  struct {
    // The unique identifier of this registration.
    ID             int64
    // The name of this registration.
    Name           string
    // An optional description of this registration.
    Description    string
    // A base URL of the Scanner Adapter.
    EndpointURL    string
    // An optional value of the HTTP Authorization header sent with each request to the Scanner Adapter API.
    Authorization  string
    // A flag indicating whether this registration is the default one.
    IsDefault      bool
}

// Registry defines methods for managing the configurations for invoking a Scanner Adapter.
type Registry interface {
    // List returns a list of currently configured scanner registrations.
    List() ([]*Registration, error)
    // Create creates a new scanner registration with the given data.
    // Returns the scanner registration identifier.
    Create(registration *Registration) (int64, error)
    // Get returns the details of the specified scanner registration.
    Get(registrationID int64) (*Registration, error)
    // Update updates the specified scanner registration.
    Update(registration *Registration) error
    // Delete deletes the specified scanner registration.
    Delete(registrationID int64) (*Registration, error)
    // SetAsDefault marks the specified scanner registration as default.
    // The implementation is supposed to unset any registration previously set as default.
    SetAsDefault(registrationID int64) error
    // GetDefault returns the default scanner registration or `nil` if there are no registrations configured.
    GetDefault() (*Registration, error)
    // Ping pings Scanner Adapter to test EndpointURL and Authorization settings.
    // The implementation is supposed to call the GetHealth method on scanner.Client.
    // Returns `nil` if connection succeeded, a non `nil` error otherwise.
    Ping(settings *RegistrationSettings) error
}
```

The implementation of the `scanner.Registry` interface will persist `Registration` entities in the Harbor DB.
There will be a new `scanner_registration` table and the corresponding
`scanner_registration_id_seq` sequence.

```sql
create table scanner_registration
(
  id serial not null constraint scanner_registration_pkey primary key,
  name varchar(255) not null constraint scanner_registry_name_key unique,
  description varchar(255),
  endpoint_url varchar(255) not null,
  "authorization" varchar(255),
  default_flag boolean default false not null
);

create sequence scanner_registration_id_seq;
```

The Harbor API will be extended with paths pertinent to Scanner Registry management as specified in
[Harbor API for Scanner Registry management (DELTA) v1.10](assets/pluggable-image-vulnerability-scanning/harbor-api-delta-scanner-registry-mgmt.yaml).

> Note: Swagger 2.0 spec yaml file can be opened in the online [Swagger Editor](https://editor.swagger.io).

### Configuration

![scanner-registration-list][scanner-registration-list-img]

A Harbor admin can configure Scanner Registrations in Harbor web console. There is a dedicated tab named *Scanners* in
the *Configuration* tabbed pane. By default the tab displays a list of currently configured Scanner Registrations.

1. Only one Scanner Registration can be marked as default at the time.
2. The admin can change the default Scanner Registration and the change will take effect only for subsequent scan
   requests.
3. The default Scanner Registration is inherited by each Harbor project. This could be extended to configure multiple
   scanners per project but is not in scope of phase 1.
4. The *Scanners* tab supports CRUD operations for Scanner Registrations.

![scanner-registration-form][scanner-registration-form-img]

When creating or updating a Scanner Registration a Harbor admin has to specify the following properties: Name,
(Optional) Description, Endpoint URL, and (Optional) Authorization header. The form allows the admin to test connection
params by making an HTTP GET request to the `/api/v1/metadata` endpoint path of the Scanner Adapter being configured.

### Scanner Adapter Client

Given a Scanner Registration settings, it provides functions for accessing the Scanner Adapter API to the Scan Job.
Transparently polls the API for getting the results back until the results are ready or an error occurs.

```go
package scanner

// Metadata represents scanner metadata and capabilities.
type Metadata struct {
    Scanner      Scanner
    Capabilities []Capability
}

type Scanner struct {
    Name    string
    Vendor  string
    Version string
}

// Capability consists of the set of recognized artifact MIME types and the set of scanner report MIME types.
// For example, a scanner capable of analyzing Docker images and producing a vulnerabilities report recognizable
// by Harbor web console might be represented with the following capability:
// - artifact MIME types:
//   - `application/vnd.oci.image.manifest.v1+json`
//   - `application/vnd.docker.distribution.manifest.v2+json`
// - report MIME types:
//   - `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0`
type Capability struct {
    artifactMIMETypes  []string
    reportMIMETypes    []string
}

// Registry represents Registry connection settings.
type Registry struct {
    // A base URL of the Docker Registry v2 API exposed by Harbor.
    URL           string
    // An optional value of the HTTP Authorization header sent with each request to the Docker Registry v2 API.
    // For example, `Bearer: JWTTOKENGOESHERE`.
    Authorization string
}

// Artifact represents an artifact stored in Registry.
type Artifact struct {
    // The name of a Harbor repository containing the artifact.
    // For example, `library/oracle/nosql`.
    Repository    string
    // The artifact's digest, consisting of an algorithm and hex portion.
    // For example, `sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b`,
    // represents sha256 based digest.
    Digest        string
}

// ScanRequest represents a structure that is sent to a Scanner Adapter to initiate artifact scanning.
// Conducts all the details required to pull the artifact from a Harbor registry.
type ScanRequest struct {
    // The unique identifier of this request generated by Harbor.
    // Used as a correlation identifier to get the scan report back.
    ID       string
    // Connection settings for the Docker Registry v2 API exposed by Harbor.
    Registry Registry
    // Artifact to be scanned.
    Artifact Artifact
}

// Represents a unified image vulnerabilities report that can be rendered in the Harbor web console.
// Corresponds to the `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0` report MIME type.
type HarborVulnerabilityReport struct {
    Artifact        Artifact
    Scanner         Scanner
    Severity        Severity
    Overview        *ComponentsOverview
    Vulnerabilities []*VulnerabilityItem
}

// Client provides functions for accessing Scanner Adapter API.
type Client struct{}

// NewClient constructs a client with the given Scanner Registration settings,
// i.e. a combination of Scanner Adapter's endpoint URL and optional Authorization header.
func NewClient(settings *RegistrationSettings) (*Client, error) {
    return nil, errors.New("not implemented")
}

// GetHealth checks health of the Scanner Adapter.
// Returns `nil` if it's healthy, a non `nil` error otherwise.
func (c *Client) GetHealth() error {
    return errrors.New("not implemented")
}

// GetMetadata gets the scanner's metadata.
func (c *Client) GetMetadata() (*Metadata, error) {
    return nil, errors.New("not implemented")
}

// SubmitScan initiates a scanning of the given artifact.
// Returns `nil` if the request was accepted, a non `nil` error otherwise.
func (c *Client) SubmitScan(req ScanRequest) error {
    return errors.New("not implemented")
}

// GetScanReport gets the scan result for the corresponding ScanRequest identifier.
// Note that this is a blocking method which either returns a non `nil` scan report or error.
// A caller is supposed to cast the returned interface{} to a structure that corresponds
// to the specified MIME type.
func (c *Client) GetScanReport(scanRequestID, reportMIMEType string) (interface{}, error) {
    return nil, errors.New("not implemented")
}
```

### Scan Controller

Scan Controller is the top coordinator for the whole scanning procedure. It exposes several standard interface
methods for the upper Harbor API layer to call. It's running in the core service of Harbor.

```go
package scanner

// Artifact is defined to describe the resources managed by Harbor, such as Docker image or Helm chart archive.
type Artifact struct {
    MimeType   string
    Repository string
    Digest     string
}

type Options struct {
    RegistryAuthorization string
}

type ScanResultAggregate struct {
}

// Controller for the scanning procedure
type Controller interface {
    // Scan scans the given artifact.
    //
    //  Arguments:
    //    artifact *Artifact : object includes the kind and metadata of the scanning artifact.
    //    options  Options   : options for scanning, such as access token of Harbor etc.
    //
    //  Returns:
    //    string : the unique identifier of the ScanRequest for checking results
    //    error  : non-nil error if any errors occurred
    Scan(artifact *Artifact, options Options) (string, error)

    // Get the scan result
    //
    //  Arguments:
    //    scanRequestID string : the unique identifier returned by the Scan method for tracking the corresponding result
    //
    //  Returns:
    //    *ScanResult : the scanning result data
    //    error       : non-nil error if any error occurred
    GetResult(scanRequestID string) (*ScanResultAggregate, error)
}
```

When scanning requests are distributed from the upper API layer, the Scan Controller will get the default Scanner
Registration from the Scanner Registry and launch a Scan Job to handle the scanning workload.

There will be a unique scan identifier generated to track the status of the launched Scan Job. The scan identifier
will be used to get the results eventually returned by the Scanner Adapter. The result will have a unified format
suitable for rendering in Harbor web console, i.e. the client will explicitly specify the mime-type of requested
scan report in the `Accept` header to `application/vnd.scanner.adapter.vuln.report.harbor.v1+json`.

The periodical trigger way can also be supported via the job service web hook. (A special job is submitted as a periodic
job. When the tick is coming, there will be a hook event generated and published to the Hook Listener. It will raise
a request to the Scan Controller to launch the scan).

### ScanReports Storage

For result storage, Harbor should store the ScanJob UUID, artifact Identifier (repo + digest of image or object),
mime-type, timestamp, and text/json blob of the report returned (including its mime-type for marshalling).
Any additional processing of the result can be done from that record (e.g. indexing with structured rows) and is
considered future work. For this proposal, only the most recent result should be maintained, but future work can extend
it to provide a scan history/audit as needed and independently of the scanner adapter implementations. This keeps the
data model simple and supports future work for multiple report types that all can be persisted in the same database.

If considering the performance, there will probably be a Scan Store to persist the related scanning results in
the database with a predefined model (full, partial or reference?; only latest copy or all of the passed copies?) for
easily querying. Under this case, the Scan Controller can get the results from the Scan Store. The Scan Job
needs to publish the results and related status changes to the Scan Store for updates and persistence.

## Non-Goals

1. Initial multi-scanner support - Scanning each image with multiple scanners in a single scanning job (as perceived by
   the end-user)
   1. The proposal allows for a natural extension of the concept to support multi-scanner support but does not propose
      to deliver it initially. Such support should be a new proposal based upon this work
2. Supporting UI visualization of results beyond vulnerabilities

## Rationale

1. Externalized Scanner Adapters - code out-of-tree and deployment out-of-band of Harbor deployment
   1. Advantages
      1. Harbor services protected from crashes/failures of adapters
      2. Independent release cycles
      3. No source license implications (or even requirement for open-source adapters)
      4. Development independent of Harbor processes, no burden on core maintainers
   2. Disadvantages
      1. Operational overhead for users to run more services as part of Harbor deployment
      2. Restricted API has limited data context from Harbor
      3. API management (versioning etc) required with no ability to update adapters to meet new API changes
      4. Requires more security considerations because it presents another external attack surface
2. Harbor defined data model for scan results
   1. Advantages:
      1. Common schema needed to support UI visualization
      2. Can be augmented with scanner-specific data later that could be presented raw to users in UI to avoid
         per-scanner UI work
      3. Simpler for non-admins to understand results without detailed knowledge of scanners
   2. Disadvantages
      1. Lowest common denominator for scanners
      2. Harbor limited to consuming only things it understands, so must keep up with scanners to add new capabilities

## Compatibility

1. Scanner Adapter API must be versioned
2. Preserving previous scan results?
3. Existing Clair implementation vs require new Adapter for Clair? Upgrade implications

## Implementation

[A description of the steps in the implementation, who will do them, and when.]

### Work Items

1. Adapter selection and configuration framework
2. Adapter client implementation
3. Anchore Engine Adapter
4. Aqua MicroScanner Adapter
5. Clair Adapter (?)

## Open issues (if applicable)

[clair]: https://github.com/coreos/clair
[harbor-clair-deployment-img]: images/pluggable-image-vulnerability-scanning/harbor-clair-deployment.png "The deployment diagram for the current Harbor integration with Clair"
[harbor-clair-sequence-img]: images/pluggable-image-vulnerability-scanning/harbor-clair-sequence.png "The sequence diagram for the current Harbor integration with Clair"
[harbor-scanner-adapter-deployment-img]: images/pluggable-image-vulnerability-scanning/harbor-scanner-adapter-deployment.png "The deployment diagram for the proposed Harbor integration with Scanner Adapter"
[harbor-scanner-adapter-sequence-img]: images/pluggable-image-vulnerability-scanning/harbor-scanner-adapter-sequence.png "The sequence diagram for the proposed Harbor integration with Scanner Adapter"
[scanner-registration-list-img]: images/pluggable-image-vulnerability-scanning/web-console-scanner-registration-list.png "The list of currently configured Scanner Registrations"
[scanner-registration-form-img]: images/pluggable-image-vulnerability-scanning/web-console-scanner-registration-form.png "The web form for configuring new or editing an existing Scanner Registration"
